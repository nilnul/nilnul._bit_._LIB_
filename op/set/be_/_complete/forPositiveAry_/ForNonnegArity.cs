using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace nilnul.bit.op_.of_.vec.set.be_._complete
{
	/// <summary>
	/// A more natural condition would be that the clone generated by F consist of all functions ƒ: Bn → B, for all integers n ≥ 0.
	/// However, the examples given in <see cref="CompleteDisregardNaryI"/> are not functionally complete in this stronger sense because it is not possible to write a nullary function, i.e. a constant expression, in terms of F if F itself does not contain at least one nullary function.
	/// With this stronger definition, the smallest functionally complete sets would have 2 elements.
	/// </summary>
	interface ForNonnegArityI
	{

	}
}
/*en.wikipedia.org/wiki/Functional_completeness
  
 Emil Post proved that a set of logical connectives is functionally complete if and only if it is not a subset of any of the following sets of connectives:

1) The monotonic connectives; changing the truth value of any connected variables from F to T without changing any from T to F never makes these connectives change their return value from T to F, e.g. {Or,And, 1,0) .

2) The affine connectives, such that each connected variable either always or never affects the truth value these connectives return, e.g. ( not, 1,0, eq, ne).

3) The self-dual connectives, which are equal to their own de Morgan dual; if the truth values of all variables are reversed, so is the truth value these connectives return, e.g. {not, major}.

4)The truth-preserving connectives; they return the truth value T under any interpretation which assigns T to all variables, e.g. {or, and, 1, le, eq }.

5) The falsity-preserving connectives; they return the truth value F under any interpretation which assigns F to all variables, e.g. { or, and, 0, gt, ne }.
 */
